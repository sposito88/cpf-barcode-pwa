<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Scanner de CPF ‚Üí C√≥digo de Barras</title>
  <meta name="theme-color" content="#0b1020">
  <link rel="manifest" href="./manifest.webmanifest">
  <link rel="apple-touch-icon" href="./icons/icon-192.png">
  <style>
    :root { --bg:#0b1020; --card:#121936; --accent:#6ee7ff; --ok:#22c55e; --bad:#ef4444; --txt:#e5e7eb; }
    *{box-sizing:border-box} body{margin:0;background:linear-gradient(180deg,#0b1020,#0b0f1a);color:var(--txt);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif}
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    .title{display:flex;gap:12px;align-items:center;}
    .title h1{font-size:clamp(18px,3vw,28px);margin:0}
    .card{background:var(--card);border:1px solid #263157;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:14px}
    .grid{display:grid;gap:14px}
    @media(min-width:900px){.grid{grid-template-columns:1.2fr .8fr}}
    video{width:100%;border-radius:14px;background:#000}
    canvas{display:none}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{appearance:none;border:0;border-radius:12px;padding:12px 14px;font-weight:600;cursor:pointer;background:#213055;color:#dbeafe;transition:.2s}
    button:hover{filter:brightness(1.1)}
    .primary{background:linear-gradient(135deg,#2563eb,#06b6d4);color:white}
    .ghost{background:#1a2747}
    input,select{width:100%;padding:12px;border-radius:12px;border:1px solid #2b3a62;background:#0f142b;color:#e5e7eb}
    label{font-size:12px;opacity:.9}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid #2a365f;background:#0f1732}
    .ok{color:var(--ok);border-color:#1b6e3b;background:#0b2b18}
    .bad{color:var(--bad);border-color:#6e1b1b;background:#2b0b0b}
    .muted{opacity:.8}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .barcode-wrap{display:grid;place-content:center;background:#0b0f1c;border-radius:12px;padding:14px;border:1px dashed #263157}
    svg{max-width:100%}
    .foot{opacity:.7;font-size:12px;margin-top:12px}
    .progress{height:10px;background:#0f1a35;border-radius:999px;overflow:hidden;border:1px solid #203158}
    .progress>i{display:block;height:100%;background:linear-gradient(90deg,#1f8ffd,#22d3ee);width:0}
    .hint{font-size:12px;opacity:.85}
    
    /* Melhorias para PWA */
    .install-prompt{position:fixed;top:16px;right:16px;background:var(--card);border:1px solid #263157;border-radius:12px;padding:12px;box-shadow:0 4px 20px rgba(0,0,0,.3);z-index:1000;max-width:300px;display:none}
    .install-prompt.show{display:block}
    .install-prompt button{margin-top:8px;width:100%}
    .install-prompt .close{position:absolute;top:8px;right:8px;background:none;border:none;color:var(--txt);font-size:18px;cursor:pointer;padding:4px}
    
    /* Melhorias para c√¢mera */
    .camera-container{position:relative}
    .focus-indicator{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:200px;height:80px;border:2px solid var(--accent);border-radius:8px;pointer-events:none;opacity:0.7;display:none;transition:all 0.3s ease}
    .focus-indicator.active{display:block}
    .focus-indicator.focusing{border-color:#22c55e;box-shadow:0 0 20px rgba(34,197,94,0.5);animation:pulse 1s infinite}
    @keyframes pulse{0%{transform:translate(-50%,-50%) scale(1)}50%{transform:translate(-50%,-50%) scale(1.05)}100%{transform:translate(-50%,-50%) scale(1)}}
    
    /* Melhorias para feedback */
    .status-message{background:var(--card);border-radius:8px;padding:8px 12px;margin-top:8px;border-left:3px solid var(--accent);animation:slideIn 0.3s ease}
    .status-message.error{border-left-color:var(--bad)}
    .status-message.success{border-left-color:var(--ok)}
    @keyframes slideIn{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}
  </style>
  <!-- libs via CDN -->
  <script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js"></script>
</head>
<body>
  <!-- Prompt de instala√ß√£o PWA -->
  <div id="installPrompt" class="install-prompt">
    <button class="close" onclick="hideInstallPrompt()">√ó</button>
    <div>üì± Instalar app no dispositivo?</div>
    <button id="installBtn" class="primary">Instalar</button>
    <button onclick="hideInstallPrompt()" class="ghost">Agora n√£o</button>
  </div>

  <div class="wrap">
    <div class="title">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7 4H4a1 1 0 0 0-1 1v3M17 4h3a1 1 0 0 1 1 1v3M7 20H4a1 1 0 0 1-1-1v-3M17 20h3a1 1 0 0 0 1-1v-3" stroke="#6ee7ff" stroke-width="1.5" stroke-linecap="round"/><rect x="6" y="7" width="12" height="10" rx="2" stroke="#6ee7ff" stroke-width="1.5"/></svg>
      <h1>Scanner de CPF ‚Üí C√≥digo de Barras</h1>
    </div>

    <div class="grid">
      <!-- Lado esquerdo: c√¢mera e OCR -->
      <div class="card">
        <div class="row">
          <button id="btnStart" class="primary">üì∑ Ligar c√¢mera</button>
          <button id="btnShot" class="ghost" disabled>üñºÔ∏è Capturar & Ler CPF</button>
          <button id="btnStop" class="ghost" disabled>‚èπÔ∏è Desligar c√¢mera</button>
        </div>
        <div class="row">
          <button id="btnFocus" class="ghost" disabled>üéØ Focar Documento</button>
          <button id="btnAutoFocus" class="ghost" disabled>üîÑ Auto Foco</button>
        </div>
        <div class="row">
          <button id="btnExposure" class="ghost" disabled>‚òÄÔ∏è Ajustar Exposi√ß√£o</button>
          <button id="btnFlash" class="ghost" disabled>üí° Flash</button>
        </div>
        <div class="row">
          <button id="btnReset" class="ghost" disabled>üîÑ Reset C√¢mera</button>
          <button id="btnManualFocus" class="ghost" disabled>üìè Foco Manual</button>
        </div>
        <div class="hint">Dica: aponte para um documento ou texto que contenha o CPF. Boa luz ajuda o OCR.</div>
        <div class="camera-container">
          <video id="video" playsinline muted></video>
          <div id="focusIndicator" class="focus-indicator"></div>
        </div>
        <canvas id="frame"></canvas>
        <div class="row" style="margin-top:8px">
          <div class="progress" style="flex:1"><i id="pbar"></i></div>
          <span id="status" class="badge muted">Aguardando‚Ä¶</span>
        </div>
        <div id="statusMessage" class="status-message" style="display:none"></div>
      </div>

      <!-- Lado direito: resultado, valida√ß√£o e barcode -->
      <div class="card">
        <div class="row">
          <div style="flex:1">
            <label for="cpf">CPF detectado (edite se necess√°rio)</label>
            <input id="cpf" inputmode="numeric" placeholder="___.___.___-__" />
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="btnValidate" class="primary">‚úÖ Validar & Gerar C√≥digo</button>
          </div>
        </div>
        <div class="row">
          <span id="validBadge" class="badge muted">CPF n√£o verificado</span>
          <select id="symbology" title="Tipo de c√≥digo de barras">
            <option value="CODE128" selected>CODE128 (recomendado)</option>
            <option value="ITF">Interleaved 2 of 5</option>
            <option value="MSI">MSI</option>
          </select>
          <button id="btnDownload" class="ghost" disabled>‚¨áÔ∏è Baixar c√≥digo de barras (PNG)</button>
        </div>
        <div class="barcode-wrap" style="margin-top:8px">
          <svg id="barcode"></svg>
        </div>
        <div class="foot">Privacidade: todo o processamento ocorre no seu dispositivo. Nenhum dado √© enviado a servidores.</div>
      </div>
    </div>

    <p class="foot">Observa√ß√£o: o CPF possui 11 d√≠gitos e dois d√≠gitos verificadores. O app valida a sequ√™ncia e remove formata√ß√µes. Se o OCR errar algum d√≠gito, toque no campo e corrija antes de gerar o c√≥digo.</p>
  </div>

<script>
  // ==== PWA Install Prompt ====
  let deferredPrompt;
  const installPrompt = document.getElementById('installPrompt');
  const installBtn = document.getElementById('installBtn');

  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    installPrompt.classList.add('show');
  });

  installBtn.addEventListener('click', async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      if (outcome === 'accepted') {
        console.log('PWA instalado com sucesso');
      }
      deferredPrompt = null;
      hideInstallPrompt();
    }
  });

  function hideInstallPrompt() {
    installPrompt.classList.remove('show');
  }

  // ==== Utilidades CPF ====
  function onlyDigits(s){ return (s||'').replace(/\D+/g,''); }
  function formatCPF(d){ d = onlyDigits(d).slice(0,11); if(d.length<11) return d; return d.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4'); }
  function isSeq(d){ return /^([0-9])\1{10}$/.test(d); }
  function cpfCheckDigits(numbers){
    const calc = (base, factor) => {
      let sum = 0; for(let i=0;i<base.length;i++){ sum += parseInt(base[i],10) * (factor - i); }
      const rest = (sum * 10) % 11; return (rest===10||rest===11)?0:rest;
    };
    const n = onlyDigits(numbers);
    if(n.length!==11 || isSeq(n)) return false;
    const d1 = calc(n.slice(0,9), 10);
    const d2 = calc(n.slice(0,10), 11);
    return d1 === parseInt(n[9],10) && d2 === parseInt(n[10],10);
  }

  // ==== C√¢mera com foco autom√°tico ====
  const video = document.getElementById('video');
  const canvas = document.getElementById('frame');
  const btnStart = document.getElementById('btnStart');
  const btnShot  = document.getElementById('btnShot');
  const btnStop  = document.getElementById('btnStop');
  const btnFocus = document.getElementById('btnFocus');
  const btnAutoFocus = document.getElementById('btnAutoFocus');
  const btnExposure = document.getElementById('btnExposure');
  const btnFlash = document.getElementById('btnFlash');
  const btnReset = document.getElementById('btnReset');
  const btnManualFocus = document.getElementById('btnManualFocus');
  const statusEl = document.getElementById('status');
  const pbar     = document.getElementById('pbar');
  const focusIndicator = document.getElementById('focusIndicator');
  const statusMessage = document.getElementById('statusMessage');

  let stream;
  let cameraCapabilities = {};
  let focusCheckInterval = null;
  let flashEnabled = false;
  let manualFocusDistance = 0.1; // Dist√¢ncia inicial do foco manual
  
  // Fun√ß√£o para detectar capacidades da c√¢mera
  async function detectCameraCapabilities(stream) {
    if (stream && stream.getVideoTracks().length > 0) {
      const track = stream.getVideoTracks()[0];
      try {
        const capabilities = track.getCapabilities();
        cameraCapabilities = {
          focusMode: capabilities.focusMode || [],
          exposureMode: capabilities.exposureMode || [],
          whiteBalanceMode: capabilities.whiteBalanceMode || [],
          zoom: capabilities.zoom || { min: 1, max: 1 }
        };
        console.log('Capacidades da c√¢mera:', cameraCapabilities);
        return capabilities;
      } catch (e) {
        console.log('N√£o foi poss√≠vel detectar capacidades da c√¢mera:', e);
        return null;
      }
    }
    return null;
  }

  // Fun√ß√£o para detectar se a imagem est√° focada
  function detectFocusQuality(imageData) {
    const data = imageData.data;
    const width = imageData.width;
    const height = imageData.height;
    let edgeCount = 0;
    let totalPixels = 0;
    let highContrastPixels = 0;
    
    // Analisa bordas na imagem (mais sens√≠vel)
    for (let y = 1; y < height - 1; y += 1) { // Reduzi o step para mais precis√£o
      for (let x = 1; x < width - 1; x += 1) {
        totalPixels++;
        const idx = (y * width + x) * 4;
        const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        
        // Detecta bordas em m√∫ltiplas dire√ß√µes
        const right = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;
        const bottom = (data[idx + width * 4] + data[idx + width * 4 + 1] + data[idx + width * 4 + 2]) / 3;
        const diagonal = (data[idx + width * 4 + 4] + data[idx + width * 4 + 5] + data[idx + width * 4 + 6]) / 3;
        
        // Threshold mais baixo para detectar mais bordas
        const threshold = 15; // Reduzido ainda mais para ser mais sens√≠vel
        if (Math.abs(gray - right) > threshold || 
            Math.abs(gray - bottom) > threshold || 
            Math.abs(gray - diagonal) > threshold) {
          edgeCount++;
        }
        
        // Detecta pixels de alto contraste
        if (Math.abs(gray - right) > 50 || Math.abs(gray - bottom) > 50) {
          highContrastPixels++;
        }
      }
    }
    
    const focusScore = edgeCount / totalPixels;
    const contrastScore = highContrastPixels / totalPixels;
    const combinedScore = (focusScore * 0.7) + (contrastScore * 0.3);
    
    console.log('Score de foco:', focusScore, 'Contraste:', contrastScore, 'Combinado:', combinedScore, 'Bordas:', edgeCount, 'Total:', totalPixels);
    
    // Thresholds ajustados para ser mais sens√≠vel
    return {
      score: combinedScore,
      isFocused: combinedScore > 0.03, // Reduzido ainda mais
      quality: combinedScore > 0.12 ? 'excelente' : combinedScore > 0.06 ? 'boa' : combinedScore > 0.03 ? 'aceit√°vel' : 'ruim'
    };
  }

  // Fun√ß√£o para controlar flash
  async function toggleFlash() {
    if (!stream) return;
    
    const track = stream.getVideoTracks()[0];
    if (!track) return;

    try {
      flashEnabled = !flashEnabled;
      
      if (flashEnabled) {
        showStatusMessage('Ativando flash...', 'success');
        
        // Tenta ativar o flash
        await track.applyConstraints({
          advanced: [{
            torch: true
          }]
        });
        
        btnFlash.textContent = 'üí° Flash ON';
        btnFlash.style.background = 'linear-gradient(135deg,#f59e0b,#ef4444)';
        showStatusMessage('Flash ativado!', 'success');
        
      } else {
        showStatusMessage('Desativando flash...', 'success');
        
        // Desativa o flash
        await track.applyConstraints({
          advanced: [{
            torch: false
          }]
        });
        
        btnFlash.textContent = 'üí° Flash';
        btnFlash.style.background = '';
        showStatusMessage('Flash desativado', 'success');
      }
      
    } catch (e) {
      console.log('Erro ao controlar flash:', e);
      flashEnabled = false;
      btnFlash.textContent = 'üí° Flash';
      btnFlash.style.background = '';
      showStatusMessage('Flash n√£o dispon√≠vel nesta c√¢mera', 'error');
    }
  }

  // Fun√ß√£o para foco manual preciso
  async function applyPreciseManualFocus() {
    if (!stream) {
      showStatusMessage('C√¢mera n√£o est√° ativa', 'error');
      return;
    }
    
    const track = stream.getVideoTracks()[0];
    if (!track) return;

    try {
      focusIndicator.classList.add('focusing');
      showStatusMessage('Aplicando foco manual preciso...', 'success');
      
      // Tenta diferentes dist√¢ncias de foco manual
      const distances = [0.05, 0.1, 0.15, 0.2, 0.3, 0.5];
      
      for (let i = 0; i < distances.length; i++) {
        const distance = distances[i];
        try {
          console.log(`Tentativa ${i + 1}: Foco manual com dist√¢ncia ${distance}`);
          
          await track.applyConstraints({
            advanced: [{
              focusMode: 'manual',
              focusDistance: distance
            }]
          });
          
          // Aguarda um pouco para o foco se estabilizar
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Verifica a qualidade do foco
          const w = video.videoWidth;
          const h = video.videoHeight;
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0, w, h);
          const imageData = ctx.getImageData(0, 0, w, h);
          
          const focusQuality = detectFocusQuality(imageData);
          console.log(`Qualidade com dist√¢ncia ${distance}:`, focusQuality);
          
          if (focusQuality.quality === 'excelente' || focusQuality.quality === 'boa') {
            manualFocusDistance = distance;
            showStatusMessage(`Foco manual aplicado com dist√¢ncia ${distance}! Qualidade: ${focusQuality.quality}`, 'success');
            break;
          }
          
        } catch (e) {
          console.log(`Erro na tentativa ${i + 1}:`, e);
          continue;
        }
      }
      
      // Retorna para foco autom√°tico ap√≥s um tempo
      setTimeout(async () => {
        try {
          await track.applyConstraints({
            advanced: [{
              focusMode: 'continuous'
            }]
          });
          console.log('Foco autom√°tico reativado');
        } catch (e) {
          console.log('Erro ao reativar foco autom√°tico:', e);
        }
        focusIndicator.classList.remove('focusing');
      }, 5000);
      
    } catch (e) {
      console.log('Erro no foco manual preciso:', e);
      focusIndicator.classList.remove('focusing');
      showStatusMessage('Erro no foco manual: ' + e.message, 'error');
    }
  }

  // Fun√ß√£o para ajustar exposi√ß√£o (lidar com brilho)
  async function adjustExposure() {
    if (!stream) return;
    
    const track = stream.getVideoTracks()[0];
    if (!track) return;

    try {
      showStatusMessage('Ajustando exposi√ß√£o...', 'success');
      
      // Tenta reduzir a exposi√ß√£o para lidar com brilho
      await track.applyConstraints({
        advanced: [{
          exposureMode: 'manual',
          exposureTime: 1000, // Tempo de exposi√ß√£o menor
          brightness: 0.8, // Reduz brilho
          contrast: 1.2 // Aumenta contraste
        }]
      });
      
      console.log('Exposi√ß√£o ajustada');
      showStatusMessage('Exposi√ß√£o ajustada para reduzir brilho', 'success');
      
      // Retorna para exposi√ß√£o autom√°tica ap√≥s um tempo
      setTimeout(async () => {
        try {
          await track.applyConstraints({
            advanced: [{
              exposureMode: 'continuous'
            }]
          });
        } catch (e) {
          console.log('Erro ao retornar exposi√ß√£o autom√°tica:', e);
        }
      }, 5000);
      
    } catch (e) {
      console.log('Erro ao ajustar exposi√ß√£o:', e);
      showStatusMessage('N√£o foi poss√≠vel ajustar exposi√ß√£o', 'error');
    }
  }

  // Fun√ß√£o para foco autom√°tico
  async function applyAutoFocus() {
    if (!stream) return;
    
    const track = stream.getVideoTracks()[0];
    if (!track) return;

    try {
      focusIndicator.classList.add('focusing');
      showStatusMessage('Aplicando foco autom√°tico...', 'success');
      
      // Primeiro ajusta exposi√ß√£o
      await adjustExposure();
      
      // Tenta diferentes modos de foco
      const focusModes = ['continuous', 'single-shot', 'manual'];
      
      for (const mode of focusModes) {
        if (cameraCapabilities.focusMode && cameraCapabilities.focusMode.includes(mode)) {
          try {
            await track.applyConstraints({
              advanced: [{
                focusMode: mode
              }]
            });
            console.log('Foco aplicado com modo:', mode);
            break;
          } catch (e) {
            console.log('Erro com modo de foco:', mode, e);
          }
        }
      }
      
      setTimeout(() => {
        focusIndicator.classList.remove('focusing');
        showStatusMessage('Foco autom√°tico aplicado!', 'success');
      }, 3000);
      
    } catch (e) {
      console.log('Erro no foco autom√°tico:', e);
      focusIndicator.classList.remove('focusing');
      showStatusMessage('Erro no foco autom√°tico: ' + e.message, 'error');
    }
  }

  // Fun√ß√£o para melhorar configura√ß√µes da c√¢mera
  async function optimizeCameraSettings(stream) {
    if (!stream || !cameraCapabilities.focusMode) return;
    
    const track = stream.getVideoTracks()[0];
    if (!track) return;

    try {
      const settings = {
        video: {
          width: { ideal: 1920, min: 1280 },
          height: { ideal: 1080, min: 720 },
          frameRate: { ideal: 30, min: 15 }
        }
      };

      // Adiciona configura√ß√µes de foco se dispon√≠vel
      if (cameraCapabilities.focusMode.includes('continuous')) {
        settings.video.focusMode = { ideal: 'continuous' };
      }
      
      if (cameraCapabilities.exposureMode.includes('continuous')) {
        settings.video.exposureMode = { ideal: 'continuous' };
      }
      
      if (cameraCapabilities.whiteBalanceMode.includes('continuous')) {
        settings.video.whiteBalanceMode = { ideal: 'continuous' };
      }

      await track.applyConstraints(settings);
      console.log('Configura√ß√µes da c√¢mera otimizadas');
      
    } catch (e) {
      console.log('Erro ao otimizar configura√ß√µes:', e);
    }
  }

  async function startCamera(){
    try{
      // Primeira tentativa com configura√ß√µes b√°sicas
      let constraints = {
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 1920, min: 1280 },
          height: { ideal: 1080, min: 720 }
        },
        audio: false
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      
      // Detecta capacidades da c√¢mera
      await detectCameraCapabilities(stream);
      
      // Otimiza configura√ß√µes baseado nas capacidades
      await optimizeCameraSettings(stream);
      
      video.srcObject = stream;
      
      // Aguarda o v√≠deo carregar
      await new Promise((resolve) => {
        video.onloadedmetadata = resolve;
      });
      
      await video.play();
      
      // Mostra indicador de foco
      focusIndicator.classList.add('active');
      
      btnShot.disabled = false;
      btnStop.disabled = false;
      btnFocus.disabled = false;
      btnAutoFocus.disabled = false;
      btnExposure.disabled = false;
      btnFlash.disabled = false;
      btnReset.disabled = false;
      btnManualFocus.disabled = false;
      btnStart.disabled = true;
      
      // Inicia monitoramento de foco
      startFocusMonitoring();
      
      setStatus('C√¢mera ligada. Use os bot√µes de foco ou toque na tela.');
      showStatusMessage('C√¢mera ativada! Use os bot√µes de foco para melhorar a qualidade da imagem.', 'success');
      
      // Adiciona eventos de toque para foco
      video.addEventListener('click', (e) => {
        applyManualFocus(e.clientX, e.clientY);
      });
      
      // Adiciona evento de toque no indicador de foco
      focusIndicator.addEventListener('click', (e) => {
        e.stopPropagation();
        const rect = video.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        applyManualFocus(centerX, centerY);
      });
      
      // Adiciona dicas visuais
      setTimeout(() => {
        if (focusIndicator.classList.contains('active')) {
          showStatusMessage('üí° Dica: Use os bot√µes de foco para melhorar a qualidade da imagem', 'success');
        }
      }, 3000);
      
    }catch(e){
      console.error('Erro na c√¢mera:', e);
      showStatusMessage('Erro ao acessar c√¢mera: ' + e.message, 'error');
      
      // Tenta configura√ß√£o mais simples se falhar
      try {
        console.log('Tentando configura√ß√£o alternativa...');
        stream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'environment' }, 
          audio: false 
        });
        
        video.srcObject = stream;
        await video.play();
        
        btnShot.disabled = false;
        btnStop.disabled = false;
        btnFocus.disabled = false;
        btnAutoFocus.disabled = false;
        btnExposure.disabled = false;
        btnFlash.disabled = false;
        btnReset.disabled = false;
        btnManualFocus.disabled = false;
        btnStart.disabled = true;
        
        setStatus('C√¢mera ligada (modo b√°sico)');
        showStatusMessage('C√¢mera ativada em modo b√°sico. O foco pode n√£o funcionar automaticamente.', 'error');
        
      } catch (e2) {
        alert('N√£o foi poss√≠vel acessar a c√¢mera: ' + e2.message);
      }
    }
  }
  
  function stopCamera(){
    if(stream){
      stream.getTracks().forEach(t => t.stop());
    }
    focusIndicator.classList.remove('active', 'focusing');
    focusIndicator.style.borderColor = '';
    focusIndicator.style.boxShadow = '';
    btnStart.disabled = false;
    btnShot.disabled = true;
    btnStop.disabled = true;
    btnFocus.disabled = true;
    btnAutoFocus.disabled = true;
    btnExposure.disabled = true;
    btnFlash.disabled = true;
    btnReset.disabled = true;
    btnManualFocus.disabled = true;
    setStatus('C√¢mera desligada');
    hideStatusMessage();
    
    // Para o monitoramento de foco
    stopFocusMonitoring();
  }

  btnStart.onclick = startCamera;
  btnStop.onclick = stopCamera;
  btnFocus.onclick = () => {
    const rect = video.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    applyManualFocus(centerX, centerY);
  };
  btnAutoFocus.onclick = applyAutoFocus;
  btnExposure.onclick = adjustExposure;
  btnFlash.onclick = toggleFlash;
  btnManualFocus.onclick = applyPreciseManualFocus;
  btnReset.onclick = () => {
    stopCamera();
    startCamera();
    showStatusMessage('C√¢mera resetada e reiniciada.', 'success');
  };

  // ==== OCR melhorado com Tesseract ====
  async function grabAndOcr(){
    if(!video.srcObject) return;
    
    const w = video.videoWidth;
    const h = video.videoHeight;
    canvas.width = w;
    canvas.height = h;
    
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, w, h);
    
    // Verifica qualidade do foco antes de processar
    const imageData = ctx.getImageData(0, 0, w, h);
    const focusQuality = detectFocusQuality(imageData);
    
    if (!focusQuality.isFocused) {
      showStatusMessage('Imagem muito desfocada! Use os bot√µes de foco primeiro.', 'error');
      setStatus('Foque a imagem antes de capturar');
      return;
    }
    
    showStatusMessage(`Qualidade do foco: ${focusQuality.quality}. Processando...`, 'success');
    
    // Melhora a imagem antes do OCR
    const data = imageData.data;
    
    // Aplica filtros para melhorar o reconhecimento
    for (let i = 0; i < data.length; i += 4) {
      const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
      const threshold = 128;
      const binary = gray > threshold ? 255 : 0;
      data[i] = data[i + 1] = data[i + 2] = binary;
    }
    
    ctx.putImageData(imageData, 0, 0);
    const dataUrl = canvas.toDataURL('image/png');

    setStatus('Lendo imagem‚Ä¶');
    setProgress(5);
    showStatusMessage('Processando imagem com OCR...', 'success');
    
    try {
      const worker = await Tesseract.createWorker({
        logger: m => {
          if(m.status && m.progress != null){
            setStatus(m.status);
            setProgress(Math.round(m.progress * 100));
          }
        }
      });
      
      await worker.load();
      await worker.loadLanguage('por');
      await worker.initialize('por');
      
      // Configura√ß√µes espec√≠ficas para melhorar reconhecimento de n√∫meros
      await worker.setParameters({
        tessedit_char_whitelist: '0123456789.-',
        tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
        preserve_interword_spaces: '1'
      });
      
      const { data: { text } } = await worker.recognize(dataUrl);
      await worker.terminate();

      const candidates = extractCpfCandidates(text);
      
      if(candidates.length > 0){
        // Prioriza CPFs v√°lidos
        const validFirst = candidates.sort((a,b) => {
          const aValid = cpfCheckDigits(a);
          const bValid = cpfCheckDigits(b);
          if (aValid && !bValid) return -1;
          if (!aValid && bValid) return 1;
          return 0;
        });
        
        const picked = validFirst[0];
        setCPF(picked);
        
        if (cpfCheckDigits(picked)) {
          setStatus('CPF v√°lido detectado! Revise e gere o c√≥digo.');
          showStatusMessage('CPF v√°lido encontrado: ' + formatCPF(picked), 'success');
        } else {
          setStatus('CPF detectado (pode precisar de corre√ß√£o).');
          showStatusMessage('CPF detectado, mas verifique se est√° correto: ' + formatCPF(picked), 'error');
        }
      } else {
        setStatus('N√£o encontrei um CPF claro. Tente aproximar, melhorar a luz ou digitar manualmente.');
        showStatusMessage('Nenhum CPF encontrado na imagem. Tente melhorar o foco ou a ilumina√ß√£o.', 'error');
      }
      
    } catch (error) {
      console.error('Erro no OCR:', error);
      setStatus('Erro ao processar imagem');
      showStatusMessage('Erro no processamento OCR: ' + error.message, 'error');
    }
    
    setProgress(0);
  }

  function extractCpfCandidates(text){
    console.log('Texto extra√≠do:', text);
    
    // Limpa o texto
    const cleanText = (text || '').replace(/[Oo]/g, '0').replace(/[lI]/g, '1');
    
    // Padr√µes para CPF
    const patterns = [
      // CPF com formata√ß√£o: 123.456.789-01
      /\b\d{3}[\.\s]?\d{3}[\.\s]?\d{3}[-\s]?\d{2}\b/g,
      // CPF sem formata√ß√£o: 12345678901
      /\b\d{11}\b/g,
      // CPF parcial com formata√ß√£o
      /\b\d{3}[\.\s]?\d{3}[\.\s]?\d{3}\b/g
    ];
    
    const candidates = new Set();
    
    patterns.forEach(pattern => {
      const matches = cleanText.match(pattern) || [];
      matches.forEach(match => {
        const digits = onlyDigits(match);
        if (digits.length === 11) {
          candidates.add(digits);
        }
      });
    });
    
    // Busca por sequ√™ncias de 11 d√≠gitos consecutivos
    const allDigits = cleanText.match(/\d/g)?.join('') || '';
    for (let i = 0; i + 11 <= allDigits.length; i++) {
      const seq = allDigits.slice(i, i + 11);
      if (seq.length === 11) {
        candidates.add(seq);
      }
    }
    
    const result = Array.from(candidates).filter(s => s.length === 11);
    console.log('Candidatos encontrados:', result);
    return result;
  }

  function setStatus(msg){ statusEl.textContent = msg; }
  function setProgress(v){ pbar.style.width = Math.max(0, Math.min(100, v)) + '%'; }
  
  function showStatusMessage(message, type = 'success') {
    statusMessage.textContent = message;
    statusMessage.className = `status-message ${type}`;
    statusMessage.style.display = 'block';
  }
  
  function hideStatusMessage() {
    statusMessage.style.display = 'none';
  }

  const btnOcr = document.getElementById('btnShot');
  btnOcr.onclick = grabAndOcr;

  // ==== Campo CPF, valida√ß√£o e barcode ====
  const cpfInput = document.getElementById('cpf');
  const badge = document.getElementById('validBadge');
  const btnValidate = document.getElementById('btnValidate');
  const symSel = document.getElementById('symbology');

  function setCPF(v){ cpfInput.value = formatCPF(v); }
  cpfInput.addEventListener('input', ()=> { 
    cpfInput.value = formatCPF(cpfInput.value); 
    badge.className='badge muted'; 
    badge.textContent='CPF n√£o verificado'; 
  });

  function markValid(ok){
    if(ok){ 
      badge.className='badge ok'; 
      badge.textContent='CPF v√°lido'; 
    } else { 
      badge.className='badge bad'; 
      badge.textContent='CPF inv√°lido'; 
    }
  }

  function generateBarcode(){
    const val = onlyDigits(cpfInput.value);
    const type = symSel.value;
    
    if(!val || val.length !== 11){
      markValid(false);
      showStatusMessage('Informe um CPF com 11 d√≠gitos.', 'error');
      return;
    }
    
    const ok = cpfCheckDigits(val);
    markValid(ok);
    
    if(!ok){
      showStatusMessage('CPF inv√°lido pelo c√°lculo dos d√≠gitos verificadores. Corrija antes de gerar.', 'error');
      return;
    }
    
    try{
      JsBarcode('#barcode', val, { 
        format: type, 
        displayValue: true, 
        fontSize: 16, 
        margin: 10,
        background: '#ffffff',
        lineColor: '#000000'
      });
      document.getElementById('btnDownload').disabled = false;
      showStatusMessage('C√≥digo de barras gerado com sucesso!', 'success');
    }catch(e){
      showStatusMessage('Erro ao gerar c√≥digo: ' + e.message, 'error');
    }
  }

  btnValidate.onclick = generateBarcode;

  // ==== Download do SVG como PNG ====
  const btnDownload = document.getElementById('btnDownload');
  btnDownload.onclick = () => {
    const svg = document.getElementById('barcode');
    const xml = new XMLSerializer().serializeToString(svg);
    const svg64 = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(xml);
    const img = new Image();
    img.onload = () => {
      const c = document.createElement('canvas');
      c.width = img.width * 2; // Aumenta a resolu√ß√£o
      c.height = img.height * 2;
      const ctx = c.getContext('2d');
      ctx.scale(2, 2); // Escala para melhor qualidade
      ctx.drawImage(img, 0, 0);
      const link = document.createElement('a');
      link.download = `barcode_cpf_${onlyDigits(cpfInput.value)}.png`;
      link.href = c.toDataURL('image/png');
      link.click();
      showStatusMessage('C√≥digo de barras baixado com sucesso!', 'success');
    };
    img.src = svg64;
  };

  // ==== Service Worker registration ====
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(registration => {
          console.log('SW registrado:', registration);
        })
        .catch(error => {
          console.error('Erro no SW:', error);
        });
    });
  }

  // Fun√ß√£o para verifica√ß√£o cont√≠nua de foco
  function startFocusMonitoring() {
    if (focusCheckInterval) {
      clearInterval(focusCheckInterval);
    }
    
    focusCheckInterval = setInterval(() => {
      if (!video.srcObject || !video.videoWidth) return;
      
      try {
        const w = video.videoWidth;
        const h = video.videoHeight;
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, w, h);
        const imageData = ctx.getImageData(0, 0, w, h);
        
        const focusQuality = detectFocusQuality(imageData);
        
        // Atualiza o indicador visual baseado na qualidade
        if (focusQuality.quality === 'excelente') {
          focusIndicator.style.borderColor = '#22c55e';
          focusIndicator.style.boxShadow = '0 0 15px rgba(34,197,94,0.3)';
        } else if (focusQuality.quality === 'boa') {
          focusIndicator.style.borderColor = '#f59e0b';
          focusIndicator.style.boxShadow = '0 0 15px rgba(245,158,11,0.3)';
        } else if (focusQuality.quality === 'aceit√°vel') {
          focusIndicator.style.borderColor = '#ef4444';
          focusIndicator.style.boxShadow = '0 0 15px rgba(239,68,68,0.3)';
        } else {
          focusIndicator.style.borderColor = '#6b7280';
          focusIndicator.style.boxShadow = 'none';
        }
        
        // Atualiza o status se a qualidade mudou significativamente
        if (focusQuality.isFocused && !btnShot.disabled) {
          setStatus(`Foco ${focusQuality.quality} - Pronto para capturar`);
        }
        
      } catch (e) {
        console.log('Erro na verifica√ß√£o de foco:', e);
      }
    }, 1000); // Verifica a cada segundo
  }
  
  function stopFocusMonitoring() {
    if (focusCheckInterval) {
      clearInterval(focusCheckInterval);
      focusCheckInterval = null;
    }
  }

  // Fun√ß√£o para aplicar foco manual (toque na tela)
  async function applyManualFocus(x, y) {
    if (!stream) {
      showStatusMessage('C√¢mera n√£o est√° ativa', 'error');
      return;
    }
    
    const track = stream.getVideoTracks()[0];
    if (!track) return;

    try {
      // Mostra anima√ß√£o de foco
      focusIndicator.classList.add('focusing');
      showStatusMessage('Aplicando foco...', 'success');
      
      // Calcula a posi√ß√£o relativa (0-1)
      const rect = video.getBoundingClientRect();
      const relativeX = (x - rect.left) / rect.width;
      const relativeY = (y - rect.top) / rect.height;
      
      console.log('Aplicando foco em:', relativeX, relativeY);
      
      // Tenta m√∫ltiplas estrat√©gias de foco
      const focusStrategies = [
        // Estrat√©gia 1: Foco manual com dist√¢ncia pr√≥xima
        {
          focusMode: 'manual',
          focusDistance: 0.05,
          pointsOfInterest: [{ x: relativeX, y: relativeY }]
        },
        // Estrat√©gia 2: Foco manual com dist√¢ncia m√©dia
        {
          focusMode: 'manual',
          focusDistance: 0.2,
          pointsOfInterest: [{ x: relativeX, y: relativeY }]
        },
        // Estrat√©gia 3: Foco autom√°tico single-shot
        {
          focusMode: 'single-shot',
          pointsOfInterest: [{ x: relativeX, y: relativeY }]
        }
      ];
      
      let focusApplied = false;
      
      for (let i = 0; i < focusStrategies.length; i++) {
        try {
          console.log(`Tentativa ${i + 1}:`, focusStrategies[i]);
          
          await track.applyConstraints({
            advanced: [focusStrategies[i]]
          });
          
          focusApplied = true;
          console.log(`Foco aplicado com estrat√©gia ${i + 1}`);
          break;
          
        } catch (e) {
          console.log(`Erro na estrat√©gia ${i + 1}:`, e);
          continue;
        }
      }
      
      if (!focusApplied) {
        // √öltima tentativa: configura√ß√µes b√°sicas
        try {
          await track.applyConstraints({
            video: {
              focusMode: 'continuous',
              exposureMode: 'continuous'
            }
          });
          console.log('Aplicado foco cont√≠nuo como fallback');
        } catch (e) {
          console.log('Erro no fallback:', e);
        }
      }
      
      showStatusMessage('Foco aplicado! Aguarde a estabiliza√ß√£o...', 'success');
      
      // Verifica qualidade do foco ap√≥s um tempo
      setTimeout(async () => {
        try {
          // Captura frame para an√°lise
          const w = video.videoWidth;
          const h = video.videoHeight;
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0, w, h);
          const imageData = ctx.getImageData(0, 0, w, h);
          
          const focusQuality = detectFocusQuality(imageData);
          console.log('Qualidade do foco:', focusQuality);
          
          if (focusQuality.isFocused) {
            showStatusMessage(`Foco ${focusQuality.quality}! Imagem pronta para captura.`, 'success');
          } else {
            showStatusMessage('Foco ainda n√£o ideal. Tente novamente ou ajuste a dist√¢ncia.', 'error');
          }
          
          // Retorna para foco autom√°tico
          try {
            await track.applyConstraints({
              advanced: [{
                focusMode: 'continuous'
              }]
            });
            console.log('Foco autom√°tico reativado');
          } catch (e) {
            console.log('Erro ao reativar foco autom√°tico:', e);
          }
          
          focusIndicator.classList.remove('focusing');
          
        } catch (e) {
          console.log('Erro ao verificar foco:', e);
          focusIndicator.classList.remove('focusing');
        }
      }, 4000); // Aumentei o tempo para 4 segundos
      
    } catch (e) {
      console.log('Erro ao aplicar foco manual:', e);
      focusIndicator.classList.remove('focusing');
      showStatusMessage('Erro ao aplicar foco: ' + e.message, 'error');
    }
  }
</script>
</body>
</html>
